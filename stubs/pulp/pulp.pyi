from collections.abc import Iterable
from typing import Any, Self

class LpVariable:
    lowBound: float | None
    upBound: float | None
    cat: str
    varValue: float | None

    def __init__(
        self,
        name: str,
        lowBound: float | None = None,
        upBound: float | None = None,
        cat: str = "Continuous",
        e: Any = None,
    ) -> None: ...
    def __add__(self, other: object) -> LpAffineExpression: ...
    def __radd__(self, other: object) -> LpAffineExpression: ...
    def __sub__(self, other: object) -> LpAffineExpression: ...
    def __rsub__(self, other: object) -> LpAffineExpression: ...
    def __mul__(self, other: object) -> LpAffineExpression: ...
    def __rmul__(self, other: object) -> LpAffineExpression: ...
    def __truediv__(self, other: object) -> LpAffineExpression: ...
    def __neg__(self) -> LpAffineExpression: ...
    def __le__(self, other: object) -> LpConstraint: ...
    def __ge__(self, other: object) -> LpConstraint: ...
    def __eq__(self, other: object) -> LpConstraint: ...  # type: ignore[override]

class LpAffineExpression:
    constant: float

    def __init__(
        self,
        e: dict[LpVariable, float] | list[tuple[LpVariable, float]] | None = None,
        constant: float = 0.0,
        name: str | None = None,
    ) -> None: ...
    def __add__(self, other: object) -> LpAffineExpression: ...
    def __radd__(self, other: object) -> LpAffineExpression: ...
    def __sub__(self, other: object) -> LpAffineExpression: ...
    def __rsub__(self, other: object) -> LpAffineExpression: ...
    def __mul__(self, other: object) -> LpAffineExpression: ...
    def __rmul__(self, other: object) -> LpAffineExpression: ...
    def __truediv__(self, other: object) -> LpAffineExpression: ...
    def __neg__(self) -> LpAffineExpression: ...
    def __le__(self, other: object) -> LpConstraint: ...
    def __ge__(self, other: object) -> LpConstraint: ...
    def __eq__(self, other: object) -> LpConstraint: ...  # type: ignore[override]

class LpConstraint:
    def __init__(
        self,
        e: LpAffineExpression | None = None,
        sense: int | None = None,
        name: str | None = None,
        rhs: float | None = None,
    ) -> None: ...

class LpSolver: ...

class LpProblem:
    objective: LpAffineExpression | None
    constraints: dict[str, LpConstraint]

    def __init__(self, name: str = "NoName", sense: int = 1) -> None: ...
    def __iadd__(
        self, other: LpAffineExpression | tuple[LpAffineExpression | LpConstraint, str] | LpConstraint
    ) -> Self: ...
    def solve(self, solver: LpSolver | None = None, **kwargs: Any) -> int: ...

LpMinimize: int
LpStatus: dict[int, str]

def lpSum(vector: Iterable[LpAffineExpression | LpVariable | int | float]) -> LpAffineExpression: ...
def value(x: LpVariable | LpAffineExpression | float) -> float: ...
def getSolver(solver: str, *args: Any, **kwargs: Any) -> LpSolver: ...
